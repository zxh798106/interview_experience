# 21年秋招校招面经分享  



# 操作系统  
## 系统调用  
**Q:系统调用和中断的区别**  
A:系统调用是应用程序主动向操作系统发起服务请求，而中断是突然到达的硬件设备的服务请求。

**Q：软中断和硬中断的区别**   
A：软中断是程序调用发生的，硬中断是外设引发的。软中断通常执行中断中可以延后执行的部分。

**Q：系统调用是什么？**  
A：系统调用是应用程序同系统之间的程序接口。

**Q：系统调用的流程**  
A：通过int $0x80指令使CPU从用户态切换到内核态，并将控制权交给系统调用过程起点system_call()函数，system_call()函数检查系统调用号，然后根据系统调用号找到所调用的内核函数入口地址。接着调用相应的函数，在返回后做一些系统检查，最后回到进程。  
https://www.cnblogs.com/wsw-seu/p/8283641.html   

## 虚拟内存    
**Q：什么是虚拟内存？**   
A：
虚拟内存是操作系统用来管理内存的一种方法，虚拟内存技术是为了使更多的程序能够在有限的内存中运行。虚拟内存本质就是把内存中的信息分出去一部分存在硬盘上，等到需要用的时候再把信息从硬盘取到内存中。   
来自<https://blog.csdn.net/LJH_Gemini/article/details/84842808?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242> 

**Q：虚拟内存如何实现的？**  
A：虚拟地址空间的地址称为逻辑地址，实际物理内存(就是内存条的大小)的地址空间称为物理地址。虚拟地址空间被分割成多个大小相同的页面(比如4k为一个页面)，物理地址空间被分割成同样大小的页框。虚拟地址的页面通过一个页表映射物理内存的页框，页表中保存着两者的对应关系。逻辑地址是CPU使用的地址，当进程要访问该进程地址空间里的某个地址时时候，将该地址的值传递给CPU，CPU访问该地址时，会经过MMU将逻辑地址转换为物理地址，之前说的页表就保存在MMU中，操作系统为每个进程都维护一个页表。（注：MMU在CPU上）

说了这么多，我们还是不清楚为什么用虚拟内存就能实现多个程序同时运行，并且切换性能很高呢？

实际上，程序运行的时候只需要部分数据存在内存中就可以了，因此只有部分页面和页框有对应值，其余的页表的数据保存在硬盘一块固定的地方(在Linux里叫swap分区，window里保存在C盘里)。当访问到某个页面在物理内存中没有对应的页框时就会发生缺页中断，这时候操作系统就将该页面保存在硬盘中的数据拷贝到物理内存中，并更新页表建立该页面和对应页框之间的映射关系。

这样做就实现了每次交换的代价很小，但是物理地址空间还是可能不够用，因此操作系统交换一些数据进物理内存的时候，也会从物理内存中移除部分页框数据到硬盘上，那到底该移出谁呢？这就涉及到页面交换算法了。
https://blog.csdn.net/shanghairuoxiao/article/details/70256247  

## 进程与线程  
**Q：进程和线程的区别**  
A：  
1、线程属于进程，而一个进程可以有多个线程，但至少有一个线程。  
2、进程在执行过程中拥有独立的内存单元，进程间不会相互影响，而多个线程共享进程的内存，一个线程挂掉将导致整个进程挂掉。（资源分配给进程，线程共享所属进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）   
3、进程是资源分配的最小单位，线程是CPU调度的最小单位。   
4、系统开销： 在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。   
5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。  
来自 <https://www.nowcoder.com/tutorial/93/7474823e71be4850a4b856290d230e20> 

**Q：操作系统的多任务是如何实现的？**
A：CPU给每个进程分配一段时间，当该进程的时间使用完毕后，CPU使用权会移交给下一个进程，进程之间的切换涉及到调度算法。  
https://blog.csdn.net/ybhuangfugui/article/details/89008159

**Q：操作系统会给每个进程分配哪些资源**  
A：
1.用于存放程序正文、数据的磁盘和内存地址空间，  
2.一组通用寄存器的当前值，堆、栈  
3.在运行时所需要的I/O设备  
4.已打开的文件等  
来自 <https://www.nowcoder.com/discuss/512320?type=1> 

**Q：线程之间共享哪些资源，独享哪些资源？**  
A：  
【同一进程间的线程共享的资源有4个】  
a. 堆，由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）  
b. 全局变量，它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的  
c. 静态变量，虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的  
d. 文件等公用资源，这个是共享的，使用这些公共资源的线程必须同步。  
【独享的资源有三个】   
a. 栈。  
b. 寄存器，这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC  
c.程序计数器PC  
原文链接：https://blog.csdn.net/boyaaboy/article/details/102541939  

**Q：有了进程，为什么还要有线程（线程产生的原因）**
A：进程在同一时间只能做一件事，如果进程在执行过程中阻塞，整个进程就会挂起，使得进程中其他不依赖于等待资源的任务也无法执行。  
https://www.nowcoder.com/tutorial/93/156e55e0579d4a678e857b34d572c278

**Q：函数 线程安全和不可重入的区别（什么是线程安全，什么是不可重入？）**  
A：
线程安全：当且仅当它被多个线程反复调用时，它会一直产生正确的结果。  
可重入：不引用任何共享数据，也就是不引用静态或全局变量。  
https://blog.csdn.net/hongchangfirst/article/details/8900434

**Q：如何保证线程安全？**  
A：原子操作、同步与锁、可重入、过度优化。  
https://blog.csdn.net/zhouzhaoxiong1227/article/details/74932180/

**Q：i++线程安全吗**  
A：不安全

**Q：进程上下文切换的步骤**  
a.切换页目录以使用新的地址空间   
b.切换内核栈  
c.切换硬件上下文  
https://blog.csdn.net/vjhghjghj/article/details/105353550  
https://blog.csdn.net/21cnbao/article/details/108860584  

**Q：进程中断的时候，谁来保存上下文**  
A：由内核栈来保存。（进程调度也是被时钟中断打断，现场（寄存器的值）保存在内核栈中）  

**Q：Linux进程切换的整体过程 **  
A：  
1.先找到vruntime最小的调度实体sched_entity（然后找到其进程描述符task_struct）  
2.切换页全局目录pgd（注意的是仅仅切换用户地址空间，内核地址空间由于是共享的不需要切换）  
3.切换内核栈  
4.切换硬件上下文（各种寄存器的值，保存在内核栈中，prev进程上下文压入内核栈，next进程上下文从内核栈弹出）  
注：进程切换的时候会将新页表装载至MMU，刷新TLB。  
https://blog.csdn.net/21cnbao/article/details/108860584  
https://www.cnblogs.com/wickedpriest/p/4458199.html  

**Q：任务在内存中的组织方式（没找到详细的叙述）**  
A：TCB、用户栈、用户代码



# 计算机网络  



# C/C++语言  



# Linux   
